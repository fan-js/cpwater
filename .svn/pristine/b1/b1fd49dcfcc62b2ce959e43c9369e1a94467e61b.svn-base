package cn.ritac.mmbs.comm.socket;

import java.io.IOException;
import java.util.concurrent.CopyOnWriteArraySet;
import javax.websocket.OnClose;
import javax.websocket.OnError;
import javax.websocket.OnOpen;
import javax.websocket.Session;
import javax.websocket.server.ServerEndpoint;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

@ServerEndpoint(value = "/wsocket")
@Component
public class SocketManager {
	private org.slf4j.Logger logger = LoggerFactory.getLogger(this.getClass());

	/*
	 * * concurrent包的线程安全Set，用来存放每个客户端对应的MyWebSocket对象。
	 * 若要实现服务端与单一客户端通信的话，可以使用Map来存放，其中Key可以为用户标识
	 */

	private static CopyOnWriteArraySet<SocketManager> onLineUsers = new CopyOnWriteArraySet<SocketManager>();

	// 与某个客户端的连接会话，需要通过它来给客户端发送数据
	private Session session;

	/**//**
		 * 连接建立成功调用的方法
		 *
		 * @param session 可选的参数。session为与某个客户端的连接会话，需要通过它来给客户端发送数据
		 */
	/*
	*/ @OnOpen
	public void onOpen(Session session) {
		this.session = session;
		onLineUsers.add(this);
		logger.info("SocketManager:onOpen--->  握手成功，客户端已经成功建立socket连接！");

	}

	/*	*//**
			 * 连接关闭调用的方法
			 */
	/*
	*/ @OnClose
	public void onClose() {
		onLineUsers.remove(this);
		logger.info("SocketManager:onClose--->  客户端已经断开socket连接！");
	}

	/**//**
		 * 发生错误时调用
		 *
		 * @param session
		 * @param error
		 */
	/*
	*/ @OnError
	public void onError(Session session, Throwable error) {
		logger.info("SocketManager:ononError--->连接超时，客户端已经断开socket连接！" + error.getMessage());
		error.printStackTrace();
	}

	/*	*//**
			 *
			 * @param message
			 * @throws IOException
			 */
	/*
	*/ private void sendMessage(SocketManager sMager, String message) throws IOException {
		if (sMager.session.isOpen()) {
			synchronized (sMager) {
				try {
					sMager.session.getAsyncRemote().sendText(message);
				} catch (Exception e) {
					this.session.close();
				}

			}
		}

	}

	// 数据更新，群发在线用户
	public static void sendMsg(String msg) {
		for (SocketManager item : onLineUsers) {
			try {
				item.sendMessage(item, msg);
			} catch (IOException e) {
				e.printStackTrace();
				continue;
			}
		}
	}

}